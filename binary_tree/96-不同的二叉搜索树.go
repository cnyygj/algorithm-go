package binary_tree

/**
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

输入：n = 3
输出：5

动态规划：

定义两个函数：
1、G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。
2、F(i,n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 (1 <= i <= n)。

不同的二叉搜索树的总数 G(n), 是对遍历所有 (1 <= i <= n) 的 F(i,n) 之和
G(n) = F(1,n) + F(2,n) + ... + F(n,n)

当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：
G(0)=1, G(1)=1

给定序列 1⋯n，我们选择数字 i 作为根，则根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树

举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 [1,2,3,4,5,6,7]，我们需要从左子序列 [1,2] 构建左子树，从右子序列 [4,5,6,7] 构建右子树，然后将它们组合（即笛卡尔积）
对于这个例子，不同二叉搜索树的个数为 F(3,7)
我们将 [1,2] 构建不同左子树的数量表示为 G(2), 从 [4,5,6,7] 构建不同右子树的数量表示为 G(4)，注意到 G(n) 和序列的内容无关，只和序列的长度有关。于是，F(3,7)=G(2)⋅G(4)。

因此，我们可以得到以下公式：
F(i,n)=G(i−1)⋅G(n−i)

所以：
G(n)=G(0)⋅G(n−1)+G(1)⋅G(n−2)+...+G(n−1)⋅G(0)


*/


func numTrees(n int) int {
	G := make([]int, n + 1)
	G[0], G[1] = 1, 1
	for i := 2; i <= n; i++ {
		for j := 1; j <= i; j++ {
			G[i] += G[j-1] * G[i-j]
		}
	}
	return G[n]
}
