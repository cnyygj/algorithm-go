package dp

/**
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 */


/**
方法1
时间复杂度：O(n)
空间复杂度：O(1)
思路：
1. 遍历数组，记录最小值
2. 每次遍历，计算当前值与最小值的差值，并与最大利润比较，取最大值
3. 返回最大利润
 */
func maxProfit(prices []int) int {
	var profit int
	min := prices[0]

	for i := 1; i < len(prices);i ++ {
		profit = max(profit, prices[i]-min)
		if prices[i] < min {
			min = prices[i]
		}
	}

	return profit
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

/**
方法2：
时间复杂度：O(n)
空间复杂度：O(n)
思路：
- 状态：
	长度为len(prices)的状态数组dp
	dp[i]为int类型，表示从第1天开始到第i+1天为止[0,i]买卖股票所能得到的最大利润
- 起始状态：
	当i==0时，由于只能在不同的日期买卖，因此只有1天时不能进行买卖；即dp[0]=0
- 状态转移：
	- 如果在第i+1天没有卖出：
		则该天没有利润，因此与前一天的最大利润保持相同；即dp[i]=dp[i-1]
	- 如果在第i+1天卖出：
		如果第i+1天卖出了股票，则买入股票的时间一定要在第i+1天之前，且为了保证买卖得到的收益最大，所以要保证买入的价格是前i天最低的价格；因此维护一个前i天[0,i-1]的股票价格最小值minPrice作为买入时机
		该天的最大利润=第i+1天的股票价格-前i天股票价格最小值；即dp[i]=prices[i]-minPrice
	- 因为第i+1天可能卖出也可能没卖出，且要求最大利润，因此取上述两种情况的较大值作为第i+1天最终的最大利润；即dp[i]=max(dp[i-1], prices[i]-minPrice)
	- 当i==n-1时，该子问题的解就是全局问题的解
 */
func maxProfit2(prices []int) int {
	// 状态：
	// 长度为len(prices)的状态数组dp
	// dp[i]为int类型，表示从第1天开始到第i+1天为止[0,i]买卖股票所能得到的最大利润
	n := len(prices)
	dp := make([]int, n)

	// 起始状态：
	// 当i==0时，由于只能在不同的日期买卖，因此只有1天时不能进行买卖；即dp[0]=0
	dp[0] = 0

	// 如果第i+1天卖出了股票，则买入股票的时间一定要在第i+1天之前，且为了保证买卖得到的收益最大，所以要保证买入的价格是前i天最低的价格；因此维护一个前i天[0,i-1]的股票价格最小值minPrice作为买入时机
	minPrice := prices[0]

	// 状态转移：
	for i := 1; i < n; i++ {
		// 如果在第i+1天没有卖出：则该天没有利润，因此与前一天的最大利润保持相同；即dp[i]=dp[i-1]
		// 如果在第i+1天卖出：该天的最大利润=第i+1天的股票价格-前i天股票价格最小值；即dp[i]=prices[i]-minPrice
		// 因为第i+1天可能卖出也可能没卖出，且要求最大利润，因此取上述两种情况的较大值作为第i+1天最终的最大利润；即dp[i]=max(dp[i-1], prices[i]-minPrice)
		dp[i] = max(dp[i-1], prices[i]-minPrice)
		// 更新前i天的最小值，用于后续计算
		minPrice = min(minPrice, prices[i])
	}

	// 当i==n-1时，该子问题的解就是全局问题的解
	return dp[n-1]
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}


